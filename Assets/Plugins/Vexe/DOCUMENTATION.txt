
* What:
VFW is both a runtime and editor framework that offers much more advance features than what comes out of the box with Unity.
For instance, a custom serialization system supporting types Unity doesn't, a better property drawing API,
a faster GUI layout system for editor, tons of attributes/drawers, helper types and more.

* License:
VFW is completely free and under the MIT license, so you are free to use it however you wish!

* Usage:
To get all these benefits, you just inherit BetterBehaviour instead of MonoBehaviour and BetterScriptableObject instead of ScriptableObject, and don't forget to add your using statement:

using Vexe.Runtime.Types;
using etc;

public TestBehaviour|TestObject : BetterBehaviour|BetterScriptableObject
{
    public Dictionary<int, GameObject> someDictionary;
    public uAction someAction;
    public List<int[]> someList { get; set; }
}

* Serialization:
The serialization system supports the following:
- Polymorphic types (interfaces and abstract/base system objects)
- Generic types. (you can go crazy with nesting generics. i.e. Dictionary<int, Dictionary<List<ISomeInterface>>>)
- Auto-properties (properties with side-effects are *not* serialized. Instead, you just serialize the backing field behind it)
- static fields/auto-properties can be serialized *only* in BetterBehaviours, not in any arbitrary System.Object
- readonly fields!
- Structs, custom classes and Nullables
- Most common collection types: arrays (one dimensional), List<T>, Dictionary<TK, TV>, Stack<T>, Queue<T> and HashSet<T>
- Delegates support with Action/Func-like equivalents: uAction and uFunc (supports up to 4 type arguments)
- You can have your own serialization logic with your own attributes! (more on the default serialization logic/attributes later)

* What it doesn't support:
- The serialization system is meant to serialize types that Unity doesn't support. Serialization of Unity objects is handled by Unity itself.
When the serializer comes across a UnityEngine.Object reference, it stores it in a serialized list of Unity objects, and serializes the index
of where that storage took place in the list (it's basically a hack). That means, in order to properly serialize Unity objects to Stream,
converters/surrogates must be written (Look forward to my FastSave which hopefully will be out soon)

* The exact serialization rules are as follows:
- Public fields are serialized by default
- Auto-properties with at least a public getter or setter are serialized by default
- Properties with side-effects (have bodies for their getter/setter) are never serialized
- Any non-public field or auto-property marked with [SerializeField] or [Serialize] are serialized
- Public fields/auto-properties are not serialized if marked with [DontSerialize] or [NonSerialized]. Note it's better to use [DontSerialize] because it can be used on Properties unlike [NonSerialized]
- All the previous applies on readonly fields
- For static fields/auto-properties, all the previous is applied if they're in a BetterBehaviour.
  They might not be serialized in System.Objects depending on the serializer of use. For ex,
  FullSerializer doesn't support serialization of static fields/auto-properties, but FastSerializer does (will be released soon)
- No need to mark types with any attribute to make them [Serializable] (in fact, it's recommended that you don't mark types with [Serializable], see note below)

NOTE:
Since BetterBehaviour is a MonoBehaviour, that means all the Unity serialization rules still apply.
That is, public fields (with serializable types) are serialized by default, non-public fields (with
serializable types) are serialized only when annotated with [SerializeField].
That means, if you do have a public field or non-public marked with [SerializeField], it will be
serialized twice! one by Unity, another by Vfw. So it's better to avoid friction with Unity's
serialization system by making things only serializable once by Vfw (if you can help it)
The way to achieve that for non-public fields is easy, you just don't use [SerializeField] but [Serialize] instead.
For public fields, there's two things you could:
1- Use a public auto-property instead.
2- Make the field readonly (works perfectly well if your field in public only because you want to
expose it in the inspector, and not modify it from code - my personal favorite approach)

* How to write converters/surrogates to customize serialization for/add support to certain types?
- For FullSerializer, see FS's repo for examples https://github.com/jacobdufault/fullserializer#
  Also see MethodInfoConverter.cs under Vexe/Runtime/Serialization/Serializers/FullSerializer
  After you write the converter, make sure to add it in FullSerializerBackend.cs upon initializing it

* How to view the serialize state of a BetterBehaviour?
- Just collapse the script header foldout, from there you'll see the runtime serialization data

* How do you serialize a BetterBehaviour to file?
- Like we mentioned before, serialization of Unity objects is done by storing the object in a
  serializable list (by Unity) and serializing the index of the storage location. That doesn't play
  well with saving things to Stream (File for ex) because then the receiving end must have the same
  list available for deserialization to work, which isn't very practical. This is why the
  serialization system is mainly meant and designed for persisting data between assembly reloads.
  That said, you could still try to write the serialization data of a behaviour to file, it will
  work nicely with non-UnityObject members such as dictionary, list etc. See SaveLoadExample.cs
